entire thing:

function Invoke-IncidentTemplate {
    param($templateKey, $templateInfo)

    Write-Host ""
    Write-Host "Processing: $templateKey" -ForegroundColor Cyan
    Write-Host "Description: $($templateInfo.description)" -ForegroundColor Yellow
    Write-Host ""

    # Download template
    $templateUrl = "$repoUrl/$($templateInfo.file)"
    $templatePath = "$cacheDir\temp_template.html"

    try {
        Invoke-WebRequest -Uri $templateUrl -OutFile $templatePath -UseBasicParsing
    }
    catch {
        Write-Host "ERROR: Cannot download template: $($templateInfo.file)" -ForegroundColor Red
        return
    }

    # Read template content
    $templateContent = Get-Content $templatePath -Raw

    # Extract all template variables
    $variables = @()
    $matches = [regex]::Matches($templateContent, '\{\{([^}]+)\}\}')
    foreach ($match in $matches) {
        $varName = $match.Groups[1].Value
        if ($variables -notcontains $varName) {
            $variables += $varName
        }
    }

    if ($variables.Count -eq 0) {
        Write-Host "No template variables found. Copying raw template..." -ForegroundColor Yellow
        Set-Clipboard -Value $templateContent
        Write-Host "SUCCESS: Template copied to clipboard!" -ForegroundColor Green
        return
    }

    # Collect user inputs for each variable
    Write-Host "Fill in the following information:" -ForegroundColor Green
    Write-Host "─────────────────────────────────────" -ForegroundColor Green

    $userInputs = @{}
    foreach ($variable in $variables) {

        # Provide helpful prompts for common variables
        $prompt = switch ($variable) {
            "INCIDENT_ID" { "Incident ID (e.g., INC-2025-001234)" }
            "DISCOVERY_TIME" { "Discovery time (e.g., 2025-09-04 14:30 EDT)" }
            "AFFECTED_SYSTEMS" { "Affected systems (e.g., Email servers, File shares)" }
            "INITIAL_ASSESSMENT" { "Initial assessment/description of the incident" }
            "ACTIONS_TAKEN" { "Immediate actions taken (use HTML list format: <li>Action 1</li><li>Action 2</li>)" }
            "CURRENT_STATUS" { "Current status (e.g., Under Investigation, Contained, Resolved)" }
            "NEXT_UPDATE" { "Next update time (e.g., 2025-09-04 16:00 EDT)" }
            "INCIDENT_COMMANDER" { "Incident commander name and contact" }
            "EXEC_BRIEFING_TIME" { "Executive briefing time (e.g., 2025-09-04 15:00 EDT)" }
            "CONTACT_INFO" { "CTFC contact information" }
            "ALERT_ID" { "Alert ID (e.g., ALT-2025-001234)" }
            "DETECTION_TIME" { "Detection time (e.g., 2025-09-04 14:30 EDT)" }
            "AFFECTED_AREA" { "Affected area/department" }
            "ALERT_SUMMARY" { "Brief alert summary" }
            "CURRENT_RESPONSE" { "Current response actions" }
            "ACTION_REQUIRED" { "Management action required" }
            "ACTION_TIMELINE" { "Action timeline/deadline" }
            "POC_NAME" { "Point of contact name" }
            "POC_CONTACT" { "Point of contact (email/phone)" }
            "MAINTENANCE_WINDOW" { "Maintenance window (e.g., 2025-09-07 02:00-06:00 EDT)" }
            "EXPECTED_DURATION" { "Expected duration (e.g., 4 hours)" }
            "IMPACT_LEVEL" { "Impact level (e.g., Low, Medium, High)" }
            "MAINTENANCE_DESCRIPTION" { "Description of maintenance work" }
            "SERVICE_IMPACT" { "Expected service impact during maintenance" }
            "MAINTENANCE_LEAD" { "Maintenance lead name" }
            "CONTACT_NUMBER" { "Contact phone number" }
            "CONTACT_EMAIL" { "Contact email address" }
            "CTFC_CONTACT_INFO" { "CTFC contact information" }
            default { $variable.Replace("_", " ").ToLower() }
        }

        do {
            Write-Host ""
            $input = Read-Host "Enter $prompt"
            if ([string]::IsNullOrWhiteSpace($input)) {
                Write-Host "This field cannot be empty. Please enter a value." -ForegroundColor Yellow
            }
        } while ([string]::IsNullOrWhiteSpace($input))

        $userInputs[$variable] = $input
    }

    # Replace template variables with user inputs
    $finalContent = $templateContent
    foreach ($variable in $userInputs.Keys) {
        $finalContent = $finalContent.Replace("{{$variable}}", $userInputs[$variable])
    }

    # Add generation timestamp
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss EDT"
    $analyst = $env:USERNAME

    $finalContent += @"


<!-- Generated by CTFC Toolkit -->
<!-- Timestamp: $timestamp -->
<!-- Analyst: $analyst -->
<!-- Template: $templateKey -->
"@

    try {
        Set-Clipboard -Value $finalContent
        Write-Host ""
        Write-Host "SUCCESS: Complete email template copied to clipboard!" -ForegroundColor Green
        Write-Host "Ready to paste into Outlook or email client." -ForegroundColor Cyan
        Write-Host ""
        Write-Host "Template generated at: $timestamp" -ForegroundColor DarkGray
        Write-Host "Generated by: $analyst" -ForegroundColor DarkGray
    }
    catch {
        Write-Host ""
        Write-Host "ERROR: Cannot access clipboard" -ForegroundColor Red
        Write-Host "Template generated successfully but clipboard access failed." -ForegroundColor Yellow

        # Save to temp file as backup
        $tempFile = "$env:TEMP\CTFC_Template_$(Get-Date -Format 'yyyyMMdd_HHmmss').html"
        $finalContent | Out-File -FilePath $tempFile -Encoding UTF8
        Write-Host "Backup saved to: $tempFile" -ForegroundColor Cyan
    }

    # Clean up temp template file
    if (Test-Path $templatePath) {
        Remove-Item $templatePath -Force
    }
}
